<div>[TOC]</div>
<p>&nbsp;</p>
<h3>运行时数据区结构图</h3>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612329086056.png" referrerpolicy="no-referrer" alt="1612329086056"></p>
<h2>Ⅰ 栈帧的内部结构</h2>
<blockquote><p>每调用一个方法，则往JVM栈添加一个栈帧，因此一个栈帧对应某个类的具体的一个方法，即一个栈帧对应一个方法。</p>
</blockquote>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1610814519044.png" referrerpolicy="no-referrer" alt="1610814519044"></p>
<h3>一、局部变量表</h3>
<ol>
<li><p>局部变量表也称之为<strong>局部变量数组</strong>或<strong>本地变量表</strong></p>
</li>
<li><p>定义为一个<strong>数字数组</strong>，主要用于存储<strong>方法参数</strong>和和定义在<strong>方法体内的局部变量</strong>，数据类型包括以下</p>
<ul>
<li>基本数据类型，int、long、double、char。。。</li>
<li>对象引用</li>
<li>returnAddress类型</li>

</ul>
</li>
<li><p>局部变量表是建立在<strong>线程的方法栈</strong>上，<mark>不存在安全问题</mark>，即该方法的参数不会被其他线程获取</p>
</li>
<li><p><strong>局部变量表所需的容量大小</strong>是在<strong>由Java文件编译为Class文件时确定的</strong>，保留在<strong>max_locals数据项</strong>中，在方法运行期间不会改变局部变量表的大小，<mark>编译时会进行slot的复用计算，从而得出数组所需的最大容量</mark></p>
<blockquote><p>栈帧的大小主要取决于<strong>局部变量表的大小</strong>，</p>
</blockquote>
</li>
<li><p>具体的局部变量表例子：如图为LocalVariablesTest类的main方法的局部变量表</p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1610706143460.png" referrerpolicy="no-referrer" alt="1610706143460"></p>
<ol start='6' >
<li><p>关于Slot的理解</p>
<ul>
<li><p>局部变量表的<strong>最基本存储单元</strong>——Slot（变量槽），<strong>注意：slot并不是数组的单元</strong></p>
</li>
<li><p>32以内的类型占用1个slot（包括returnAddress类型），<strong>其中byte、short、char在存储之前被转为int</strong>，Boolean转为1或0，对应true和false</p>
</li>
<li><p>64位的类型占用两个slot（long和double）</p>
</li>
<li><p>如果当前栈帧是由<strong>构造方法或非静态方法</strong>创建，那么<strong>该对象的<mark>引用this</mark>将会存放在局部变量表的<mark>首位</mark></strong>，其余再按照参数表顺序排列，即<strong>非静态方法的栈帧的局部变量表首位一定是当前对象的引用</strong> </p>
</li>
<li><p>如果方法中声明了一个变量但没有初始化，则jclass无法显示出来该变量。</p>
</li>
<li><p><strong>Slot的重复利用</strong></p>
<ul>
<li><p>如果一个局部变量过了其作用域，那么在其作用域之后申明的新的局部变量就很有可能复用过期局部变量的槽位，<mark>从而达到节省资源的目的</mark>。</p>
</li>
<li><p>例子：</p>
<pre><code class='language-java' lang='java'>public class SlotTest {
    public void localVar1() {
        // a的作用域为整个方法，此slot槽位无法重复利用
        int a = 0;
        System.out.println(a);
        int b = 0;
    }
   
    public void localVar2() {
        {
        	int a = 0;
        	System.out.println(a);   
        }
        // 上述代码被代码包含，因此变量a的作用域到此已经结束，
       	// 此时的b可以服用a的槽位
        int b = 0;
    }
}
</code></pre>
<p><img style="zoom:50%;" alt="1610723788674" src="D:\StudyDocument\MarkDown图片\1610723788674.png" data-src="D:\StudyDocument\MarkDown图片\1610723788674.png" onerror="this.style.display = 'none';"> <img style="zoom:67%;" alt="1610723982427" src="D:\StudyDocument\MarkDown图片\1610723982427.png" data-src="D:\StudyDocument\MarkDown图片\1610723982427.png" onerror="this.style.display = 'none';"></p>
</li>

</ul>
</li>

</ul>
</li>

</ol>
</li>
<li><p>局部变量与静态变量的对比</p>
<ul>
<li><p>变量可以分为：</p>
<ul>
<li><p>成员变量</p>
<ul>
<li><strong>类变量</strong>：类变量在链接的<strong>准备阶段</strong>会给类变量<strong>默认赋值</strong>，在<strong>初始化阶段</strong>进行<strong>显式赋值</strong></li>
<li>实例变量：随着对象的创建，在堆空间中分配实例变量空间，并进行默认赋值</li>

</ul>
</li>
<li><p><strong>局部变量</strong>：<strong>JVM不会进行赋值，因此使用前必须显式赋值</strong></p>
</li>

</ul>
</li>

</ul>
<blockquote><p>局部变量中slot的引用会指向堆空间的数据，如果该引用一直存在，则GC无法清理这些可能已经不会用到的垃圾，因为还有指向这些垃圾的引用，这是GC优化的一大难题。</p>
<p>解决方法：将定义的对象引用赋值为null</p>
</blockquote>
</li>

</ol>
<h3>二、操作数栈（表达式栈）</h3>
<ol>
<li><p>作用：在方法执行的过程中，根据<strong>字节码指令</strong>，<strong>往栈中写入数据或提取数据</strong>，即入栈和出栈。例如执行复制、交换、求和等操作</p>
</li>
<li><p>主要用于<strong>保存计算过程的中间结果</strong>，同时<strong>作为计算过程中变量临时的存储空间</strong></p>
</li>
<li><p>方法中的操作数栈都有一个<strong>明确的栈深度</strong>用于存储数值，其<strong>所需的最大深度在编译期就已经定义好</strong>，保存在Code属性的<strong>max_stack</strong></p>
</li>
<li><p><mark>操作栈中的任何一个元素都可以是任意的Java数据类型</mark></p>
<ul>
<li><strong>32bit的类型占用一个栈单位深度</strong>，例如char、short、int</li>
<li><strong>64bit的类型占用两个栈单位深度，</strong>，例如long、double</li>

</ul>
</li>
<li><p>栈顶缓存技术（Top of Stack Cashing）</p>
<ul>
<li>起因：由于栈式架构的虚拟机所使用的零地址指令更加紧凑，但<strong>完成一项操作的时候必然需要使用更多的入栈和出栈指令</strong></li>
<li>解决方法：由于需要多次用到栈顶元素，因此可以<strong>将栈顶元素全部缓存在物理CPU的寄存器中</strong>，以此降低对内存的读写次数，提升执行引擎的执行效率。</li>

</ul>
</li>

</ol>
<h3>三、动态链接——指向运行时常量池的方法引用</h3>
<ol>
<li>定义：每一个栈帧内部都包含一个指向<mark>运行时常量池</mark>中<mark>该栈帧所属方法</mark>的引用，即<strong>方法代码实际不在栈帧中</strong>，而是<strong>在常量池中</strong>，<strong>栈帧中保存着常量池中该方法的引用👉</strong></li>
<li>class文件中的常量池在运行期间会加载到方法区中，此时的常量池则称之为运行时常量池</li>

</ol>
<h3>四、方法的调用</h3>
<ol>
<li><p>静态链接和动态链接</p>
<ul>
<li>静态链接：当一个字节码文件（class文件）被装载进JVM内部时，如果<strong>被调用的目标方法在编译期可知</strong>，且运行期保持不变，这种情况下将调用方法的符号引用转为直接引用的过程称之为<strong>静态链接</strong>。</li>
<li>动态链接：如果被调用的方法在编译期无法被确定下来，也就是说，<strong>只能够在程序运行期将调用方法的符号引用转换为直接引用</strong>，由于这种引用转换过程具备动态性，因此也就被称之为<strong>动态链接</strong>。</li>
<li>动态绑定的例子：</li>

</ul>
</li>

</ol>
<pre><code class='language-java' lang='java'>// 父类
class Father {
    public void speak() {
        System.out.println(&quot;Father Method&quot;);
    }
}

// 子类
class Son extends Father{
	
    // 重写父类方法
    public void speak() {
        System.out.println(&quot;Son Method&quot;);
    }
}】

public class MethodTest {
    public static void main(String[] args) {
        // 父类实例
        Father father = new Father();
        // 子类实例
        Son son = new Son();
        MethodTest md = new MethodTest();
        // 参数为子类，因此该种情况调用子类方法
        md.speak(son);
        // 参数为父类，因此该种情况调用父类方法
        md.speak(father);
    }
	
    // speak方法，其中参数为Father或其子类
    public void speak(Father f) {
        f.speak();
    }
}

</code></pre>
<ol start='2' >
<li><p>早期绑定和晚期绑定</p>
<ul>
<li>绑定是一个<strong>字段、方法、或类</strong>在<strong>符号引用</strong>被替换为<strong>直接引用</strong>的过程，<mark>且这个过程仅发生一次</mark></li>
<li>早期绑定：早期绑定就是指<strong>被调用的目标方法如果在编译期可知</strong>，且运行期保持不变时即可将这个方法与所属的类型进行绑定，这样一来，由于明确了被调用的目标方法究竟是哪一个，因此也就可以使用<strong>静态链接的方式将符号引用转换为直接引用</strong>。</li>
<li>晚期绑定：如果被调用的方法在编译期无法被确定下来，<strong>只能够在程序运行期根据实际的类型绑定相关的方法</strong>，这种绑定方式也就被称之为晚期绑定。</li>

</ul>
</li>
<li><p>虚方法和非虚方法</p>
<ul>
<li>Java中<strong>任何一个普通的方法其实都具备虚函数的特征</strong>，它们相当于C++语言中的虚函数（C++中则需要使用关键字virtual来显式定义）。<strong>如果在Java程序中不希望某个方法拥有虚函数的特征时，则可以使用关键字final来标记这个方法。</strong></li>

</ul>
</li>

</ol>
<ul>
<li><p>如果方法在编译期就确定了具体的调用版本，这个版本在运行时是不可变的。这样的方法称为非虚方法</p>
<ul>
<li><strong>静态方法、私有方法、final方法、实例构造器、父类方法</strong>都是<strong>非虚方法</strong></li>
<li><strong>其他方法称为虚方法</strong></li>

</ul>
</li>

</ul>
<ol start='4' >
<li><p>调用方法指令集</p>
<ul>
<li>invokestatic:调用静态方法，解析阶段确定唯一方法版本</li>
<li>invokespecial:调用<code>&lt;init&gt;</code>方法、私有及父类方法，解析阶段确定唯一方法版本</li>
<li>invokevirtual:调用所有虚方法</li>
<li>invokeinterface:调用接口方法</li>

</ul>
</li>
<li><p>动态类型语言和静态类型语言</p>
<ul>
<li>静态类型语言是判断变量自身的类型信息，如C、Java</li>
<li>动态类型语言是判断变量值的类型信息，<strong>变量没有类型信息，变量值才有类型信息</strong>，如Python、JS</li>

</ul>
</li>

</ol>
<pre><code class='language-java' lang='java'>// java
String info = &quot;word&quot;; // info = &quot;word&quot;
</code></pre>
<pre><code class='language-javascript' lang='javascript'>// javascript
var name = &quot;sdfasd&quot;;
var name = 10;
</code></pre>
<pre><code class='language-python' lang='python'># python
info = 10.5
</code></pre>
<ol start='6' >
<li><p>Java语言中方法重写的本质</p>
<ol>
<li>找到操作数栈顶的第一个元素所执行的对象的实际类型，记作c。</li>
<li>如果在类型c中找到与常量中的描述符合简单名称都相符的方法，则进行<strong>访问权限校验</strong>，如果通过则返回这个方法的直接引用，查找过程结束;如果不通过，则返回java. lang.IllegalAccessError异常。</li>
<li><strong>否则，按照继承关系从下往上依次对c的各个父类进行第⒉步的搜索和验证过程</strong>。</li>
<li>如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常</li>
<li><code>IllegalAccessError</code>介绍：程序试图访问或修改一个属性或调用一个方法，<strong>这个属性或方法，你没有权限访问。一般的，这个会引起编译器异常</strong>。这个错误如果<strong>发生在运行时</strong>，就说明一个<strong>类发生了不兼容的改变</strong>。</li>

</ol>
</li>
<li><p>虚方法表</p>
<ul>
<li><p>在面向对象的编程中，会很频繁的使用到动态分派，<strong>如果在每次动态分派的过程中都要重新在类的方法元数据中搜索合适的目标的话就可能影响到执行效率</strong>。因此，为了提高性能，JVM采用在<strong><mark>类的方法区</mark>建立一个虚方法表</strong>( virtual method table）(<mark>非虚方法不会出现在表中</mark>)来实现。<strong>使用索引表来代替查找</strong>，<mark>主要解决方法的重写问题，可以直接找到方法的引用，无需每次都从父类中递归查找</mark>。</p>
</li>
<li><p><strong>每个类中都有一个虚方法表，表中存放着各个方法的实际入口</strong>。</p>
</li>
<li><p>那么虚方法表什么时候被创建?</p>
<ul>
<li>虚方法表会在类加载的链接阶段被创建并开始初始化，<strong>类的变量初始值准备完成之后</strong>，JVM会把该类的方法表也初始化完毕。</li>

</ul>
</li>

</ul>
<p><img style="zoom:80%;" alt="1610868311567" src="D:\StudyDocument\MarkDown图片\1610868311567.png" data-src="D:\StudyDocument\MarkDown图片\1610868311567.png" onerror="this.style.display = 'none';"></p>
</li>

</ol>
<h3>五、方法返回地址 </h3>
<ol>
<li><p>存放<strong>调用该方法的PC寄存器的值</strong></p>
</li>
<li><p><strong>一个方法的结束，有两种方式：</strong></p>
<ul>
<li>正常执行完成 </li>
<li>出现未处理的异常，非正常退出</li>

</ul>
</li>
<li><p>无论通过哪种方式退出，在方法退出后都要<strong>返回到该方法被调用的位置</strong>。方法正常退出时，<strong>调用者的pc寄存器的值作为返回地址，即调用该方法的下一条指令的地址</strong>，而通过异常退出的，返回地址是要通过<strong>异常表</strong>来确定，栈帧中一般不会保存这部分信息</p>
</li>
<li><p><strong>本质上，方法的退出就是当前栈帧出栈的过程。此时，需要恢复上层方法的局部变量表、操作数栈、将返回值压入调用者栈帧的操作数栈、设置PC寄存器值等，让调用者方法继续执行下去。</strong></p>
</li>
<li><p><strong>正常完成出口和异常完成出口的区别在于</strong></p>
<ul>
<li><mark>通过异常完成出口退出的不会给他的上层调用者产生任何的返回值</mark></li>

</ul>
</li>
<li><p>正常完成出口</p>
<ul>
<li>执行引擎遇到<strong>任意一个方法返回的字节码指令（return）</strong>，会有返回值传递给上层的方法调用者，简称<strong>正常完成出口</strong></li>
<li>且一个方法正常调用完成之后究竟需要使用哪一个返回指令还需要根据方法返回值的实际数据类型而定。</li>
<li>返回指令包括ireturn（当前返回值是boolean、byte、char、shor和int类型）、lreturn、freturn、dreturn和areturn（返回引用时）、return（void方法、实例初始化方法、类和接口的初始化方法）</li>

</ul>
</li>
<li><p>异常完成出口</p>
<ul>
<li>在方法执行的过程中遇到了异常（Exception），并且这个异常没有在方法内进行处理，也就是只要在<strong>本方法的异常表中没有搜索匹配到异常处理</strong>，就会导致方法退出。简称异常完成出口。</li>
<li>异常表：执行过程中抛出异常时的异常处理，存储在一个<strong>异常处理表</strong>。</li>

</ul>
</li>

</ol>
<pre><code class='language-java' lang='java'>public static void main(String[] args) {
    try {
        File file = new File(&quot;a.txt&quot;);
        InputStream io = new FileInputStream(file);
        System.out.println(&quot;方法体&quot;);
    } catch (IOException e) {
        System.out.println(&quot;IO出现异常&quot;);
    } catch (Exception e) {
        System.out.println(&quot;出现了任何异常&quot;);
    }
}
</code></pre>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1610898326077.png" referrerpolicy="no-referrer" alt="1610898326077"></p>
<h2>Ⅱ 本地方法栈</h2>
<ol>
<li>简单地讲，一个Native Method就是<strong>一个Java调用非Java代码的接口</strong>。</li>
<li>本地方法栈是线程私有的</li>
<li>本地方法是由C语言实现的</li>
<li>具体做法是Native Method Stack中登记Native方法，在Execution Engine执行时加载本地方法库</li>

</ol>
<p>&nbsp;</p>
<p>&nbsp;</p>
<h2>Ⅲ 堆</h2>
<h3>一、堆的核心描述</h3>
<ol>
<li><strong>一个JVM实例只存在一个堆内存</strong>，堆也是Java内存管理的核心区域</li>
<li><strong>Java堆区在JVM启动的时候即被创建， 其空间大小也就确定了</strong>，是JVM管理的最大一块内存空间。</li>
<li>堆内存的大小是可以调节的</li>

</ol>
<blockquote><p>《Java虚拟机规范》规定，堆可以处于<strong>物理上不连续</strong>的内存空间中，但在<strong>逻辑上</strong>它应该被视为<strong>连续的。</strong></p>
</blockquote>
<ol start='4' >
<li><p><strong>所有的线程共享Java堆，但在Java堆中可以划分线程私有的缓冲区</strong>（Thread Loacal Allocation Buffer，TLAB）</p>
</li>
<li><p>堆中的数据是由垃圾收集器GC来清理的</p>
</li>
<li><p>指令集中使用new指令来生成对象，且会调用类对应的构造方法</p>
</li>
<li><p>内存细分</p>
<ul>
<li><p>现代垃圾收集器大部分都基于<strong>分代收集理论</strong>设计，堆空间细分为：</p>
<p><img src="file://D:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/MarkDown%E5%9B%BE%E7%89%87/1610969412635.png" referrerpolicy="no-referrer" alt="1610969412635"></p>
</li>

</ul>
</li>

</ol>
<h3>二、设置堆内存大小与OOM</h3>
<ol>
<li><p>设置堆内存大小</p>
<ul>
<li><p>-Xms 用来设置堆空间（年轻代+老年代）的初始内存大小	</p>
<ul>
<li>-X是JVM的运行参数</li>
<li>ms是memory start，起始内存</li>

</ul>
</li>
<li><p>-Xmx：用来设置堆空间的最大内存大小</p>
</li>

</ul>
</li>
<li><p>默认堆内存</p>
<ul>
<li>初始内存大小：物理电脑内存大小 / 64</li>
<li>最大内存大小：物理内存大小 / 4</li>

</ul>
</li>

</ol>
<blockquote><p>开发中一般将初始内存和最大内存大小设置为相同的值，省去GC时的调节操作，提高运行效率</p>
</blockquote>
<h3>三、 年轻代与老年代</h3>
<ol>
<li><p>存储在JVM中Java对象可以分为两类：</p>
<ul>
<li>一类是<strong>生命周期较短的瞬时对象</strong>，这类对线的创建和消亡都非常迅速</li>
<li>另一类<strong>对象生命周期非常长</strong>，在某些极端情况下还能够与JVM的生命周期保持一致</li>

</ul>
</li>
<li><p>Java分为年轻代和老年代</p>
</li>
<li><p>年轻代又划分为以下几个区域：且survivor0和survivor1只能二选一</p>
</li>

</ol>
<p><img src="file://D:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/MarkDown%E5%9B%BE%E7%89%87/1610976326130.png" referrerpolicy="no-referrer" alt="1610976326130"></p>
<ol start='4' >
<li><p>配置新生代与老年代在堆结构的占比</p>
<ul>
<li>默认-XX:NewRatio=2，表示新生代占1，老年代占2，新生代占整个堆的1/3</li>
<li>可以修改-XX:NewRatio=4，表示新生代占1，老年代占4，新生代占整个堆的1/5</li>
<li>即NewRatio越大，老年代占比越大</li>

</ul>
</li>
<li><p>在HotSpot中，Eden空间和另外两个survivor空间缺省所占的比例是8:1:1，当然开发人员可以通过选项-XX:SurvivorRatio”调整这个空间比例。比如-xx:SurvivorRatio=8</p>
</li>
<li><p><strong>几乎所有的Java对象都是在Eden区被new出来的。</strong></p>
</li>
<li><p><strong>绝大部分的Java对象的销毁都在新生代进行了。</strong></p>
</li>
<li><p><strong>IBM 公司的专门研究表明，新生代中80% 的对象都是“朝生夕死”的</strong>。.可以使用选项&quot;-Xmn”设置新生代最大内存大小</p>
<ul>
<li>此参数一般使用默认值。</li>

</ul>
</li>
<li><p>设置新生代中<strong>Eden与Survivors区</strong>的比例</p>
<ul>
<li>-XX:SurvivorRatio:8</li>

</ul>
</li>

</ol>
<h3>四、图像对象分配过程</h3>
<ol>
<li>为新对象分配内存是一件非常严谨和复杂的任务，JVM的设计者们不仅需要考虑内存如何分配、在哪里分配等问题，并且由于内存分配算法与内存回收算法密切相关，所以还需要考虑Gc执行完内存回收后是否会在闪存空间中产生内存碎片</li>
<li>图解分配过程</li>

</ol>
<p>   <img alt="1611068974446" src="D:\StudyDocument\MarkDown图片\1611068974446.png" data-src="D:\StudyDocument\MarkDown图片\1611068974446.png" onerror="this.style.display = 'none';"></p>
<h3>五、Minor GC、Major GC、Full GC</h3>
<ol>
<li><p>需要清楚一点、JVM在进行GC时，并非对上面三个内存区域（新生代、老年代、源空间）都一起回收的，<strong>大部分回收都是指回收新生代</strong></p>
</li>
<li><p>针对HotSpot VM的实现，它里面的GC按照区域又分为两大种类型：</p>
<ul>
<li>一种是<strong>部分收集</strong>（Partial GC）</li>
<li>一种是<strong>整堆收集</strong>（Full GC）</li>

</ul>
</li>
<li><p>部分收集：不是完整回收整个Java堆的垃圾收集，其中又分为：</p>
<ul>
<li><p>新生代收集（Minor GC、Young GC）：<strong>只是新生代（Eden、S0、S1）的垃圾收集</strong></p>
</li>
<li><p>老年代收集（Major GC、Old GC）：<strong>只是老年代的垃圾收集</strong> </p>
</li>
<li><p>目前，<strong>只有CMS GC会有单独收集老年代的行为</strong></p>
</li>
<li><p>注意：很多时候Major GC和Full GC混淆使用，需要具体分辨是老年代回收还是整堆回收</p>
</li>
<li><p>混合收集：收集<strong>整个新生代以及部分老年代的垃圾收集</strong></p>
<ul>
<li>目前只有G1 GC会有这种行为</li>

</ul>
</li>

</ul>
</li>
<li><p>整堆收集：收集整个Java堆和方法区的垃圾 </p>
</li>
<li><p><strong>Minor GC会引发STW，暂停其他用户的线程，等垃圾回收结束时，用户线程才恢复运行。</strong></p>
</li>

</ol>
<h3>六、内存分配策略（对象提升规则）</h3>
<ol>
<li>如果对象在Eden出生并经过第一次MinorGC后仍然存活，并且能被survivor容纳的话，将被移动到survivor空间中，并将对象年龄设为1。<strong>对象在survivor区中每熬过一次MinorGC ,年龄就增加1 岁</strong>，当它的年龄增加到一定程度（<strong>默认为15 岁</strong>，其实每个JVM、每个cc都有所不同)时，就会被<strong>晋升到老年代</strong>中。</li>

</ol>
<blockquote><p>对象晋升老年代的年龄阈值，可以通过选项-XX:MaxTenuringThreshOld来设置</p>
</blockquote>
<ol>
<li><p>优先分配到Eden区</p>
</li>
<li><p><strong>大对象直接分配到老年代</strong></p>
<ul>
<li><strong>尽量避免程序中出现过多的大对象</strong>，因为如果老年代放不下则会触发Major GC，占用用户线程</li>

</ul>
</li>
<li><p>长期存活的对象分配到老年代</p>
</li>

</ol>
<h3>七、TLAB</h3>
<ol>
<li><p>什么是TLAB</p>
<ul>
<li>从内存模型而不是垃圾收集的角度，对Eden区域继续进行划分，<strong>JVM为每个线程分配了一个私有缓存区域</strong>，它包含在Eden空间内</li>
<li>多线程同时分配内存时，使用TLAB时可以避免一系列的非线程安全问题，同时还能够提升内存分配的吞吐量，因此我们将这种内存分配方式称为<strong>快速分配策略</strong></li>

</ul>
</li>
<li><p>TLAB的相关说明</p>
<ul>
<li>尽管不是所有的对象实例都能够在TLAB中成功分配内存，但JVM确实是<strong>将TLAB作为内存分配的首选</strong>。</li>
<li>在程序中，开发人员可以通过选项“-Xx:UseTLAB”设置是否开启TLAB空间</li>
<li><strong>默认情况下，TLAB空间的内存非常小，仅占有整个Eden空间的1%</strong></li>
<li>一旦对象在TLAB空间分配内存失败时，JVM就会尝试着通过<strong>使用加锁机制</strong>确保数<strong>据操作的原子性</strong>，从而直接在Eden空间中分配内存</li>

</ul>
</li>

</ol>
<h3>八、堆是分配对象的存储的唯一选择吗？</h3>
<blockquote><p>	前言：在《深入理解Java虚拟机》中关于Java堆内存有这样一段描述：随着<code>JIT</code>编译期的发展与<strong>逃逸分析技术</strong>逐渐成熟，<strong>栈上分配、标量替换技术</strong>将会导致一些微妙的变化，所有对象都分配到堆上也渐渐变得不是那么绝对了。</p>
</blockquote>
<ol>
<li><p>在Java虚拟机中，对象是在Java堆中分配内存的，这是一个普遍的常识，但是，有一种特殊情况，那就是<strong>如果经过逃逸分析后发现，一个对象并没有逃逸出该方法的话，那么就可能被优化成栈上分配</strong>。这样就无需在堆上分配内存，也无需进行垃圾回收了。这也是常见的<strong>堆外存储技术</strong>。</p>
</li>
<li><p>逃逸分析的基本行为就是分析对象动态作用域：</p>
<ul>
<li>当一个对象在方法中被定义后，<strong>对象只在方法内部使用</strong>，则认为没有发生逃逸</li>
<li>当一个对象在方法中被定义后，它<strong>被外部方法所引用</strong>，则认为发生逃逸。例如作为调用参数传递到其他地方中</li>

</ul>
</li>
<li><p>参数设置</p>
<ul>
<li>在JDK7后，HotSpot中默认就已经开启了逃逸分析</li>

</ul>
</li>
<li><p>结论</p>
<ul>
<li>开发中能使用局部变量的，就不要使用在方法外定义</li>

</ul>
</li>

</ol>
<h3>九、逃逸分析：代码优化</h3>
<ul>
<li><strong>通过-XX: (+/-)DoEcscapeAnalysis 来设置是否开启逃逸分析</strong></li>

</ul>
<ol>
<li><strong>栈上分配</strong>。将<strong>堆分配转化为栈分配</strong>。如果一个对象在子程序中被分配，要使指向该对象的指针永远不会逃逸，对象可能是栈分配的候选，而不是堆分配。	</li>
<li><strong>同步省略</strong>。如果一个对象被发现只能从一个线程被访问到，那么<strong>对于这个对象的操作可以不考虑同步</strong></li>
<li><strong>分离对象或标量替换</strong>。有的对象可能不需要作为一个连续的内存结构存在也可以被访问到，那么对象的部分（或全部）可以不存储在内存，而是存储在cPU寄存器中。</li>

</ol>
<h3>十、代码优化之栈上分配</h3>
<p>如果<code>JIT</code>编译器在编译期间根据逃逸分析的结果发现一个对象并没有逃逸出方法的话，就<strong>有可能被优化成栈上分配。</strong></p>
<pre><code class='language-java' lang='java'>for (int i = 0; i &lt; 10000000; i++) {
    alloc();
}

private void alloc() {
    User user = new User(); // 未逃逸对象，只在方法内使用
}

// 通过-XX: -DoEcscapeAnalysis 来设置是否开启逃逸分析

</code></pre>
<h3>十一、同步省略</h3>
<ul>
<li><p>线程同步的代价是非常高的，同步的后果是降低并发性和性能。</p>
</li>
<li><p>如果synchronize块的代码是只能够被一个线程访问而没有发布到其他线程，则<code>JIT</code>会取消这部分代码的同步，也叫做<strong>锁消除</strong></p>
<pre><code class='language-java' lang='java'>public void f() {
	Object hollis = new Object();
	synchornized(hollis) {
		System.out.println(hollis);
	}
}

/*
	代码中对Hollis这个对象加锁，但是hollis并不会被其他对象访问到，即这个锁并没有意义，因此JIT编译	     阶段会优化为以下代码
*/
public void f() {
	Object hollis = new Object();
    System.out.println.(hollis);
}
</code></pre>
</li>

</ul>
<h3>十二、标量替换</h3>
<ul>
<li><strong>标量</strong>（Scalar）是指一个无法再分解成更小的数据的数据。Java中的<strong>原始数据类型就是标量</strong>。</li>
<li>相对的，那些还可以分解的数据叫做<strong>聚合量</strong>（Aggregate），Java中的<strong>对象就是聚合量</strong>，因为它可以分解成其他聚合量和标量。</li>
<li>在<code>JIT</code>阶段，如果经过逃逸分析，发现一个对象不会被外界访问的话，那么经过<code>JIT</code>优化，不会创建该对象，而是会把这个对象拆解成若干个其中包含若干个成员变量来代替，这个过程就是<strong>标量替换</strong>。</li>

</ul>
<pre><code class='language-java' lang='java'>public static void main (String[] args) {
	alloc();
}

private static void alloc() {
	Point point = new Point(1, 2);
	System.out.println.(&quot;point.x = &quot; + point.x + &quot;; point.y = &quot; + point.y);
}

class Point {
	private int x;
	private int y;
}

// 由于对象point经过逃逸分析后并没有逃逸，就被替换成两个标量
</code></pre>
<pre><code class='language-java' lang='java'>public static class User {
        public int id;
        public String name;
    }

    public static void alloc() {
        // 未发生逃逸
        User u = new User();
        u.id = 5;
        u.name = &quot;Mike&quot;;
    }

    public static void main(String[] args) {
        long start = System.currentTimeMillis();
        for (int i = 0; i &lt; 1000000; i++) {
            alloc();
        }
        long end = System.currentTimeMillis();
        System.out.println(&quot;用时：&quot; + (end - start) + &quot;ms&quot;);
    }
</code></pre>
<p><img style="zoom:80%;" alt="1612326915706" src="D:\StudyDocument\MarkDown图片\1612326915706.png" data-src="D:\StudyDocument\MarkDown图片\1612326915706.png" onerror="this.style.display = 'none';"></p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612326974643.png" referrerpolicy="no-referrer" alt="1612326974643"></p>
<h2>Ⅳ 方法区</h2>
<h3>一、栈、堆、方法区的交互关系</h3>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612358687193.png" referrerpolicy="no-referrer" alt="1612358687193"></p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612359086290.png" referrerpolicy="no-referrer" alt="1612359086290"></p>
<blockquote><p>	内存泄漏（Memory Leak）是指程序中<strong>已动态分配的堆内存由于某种原因程序未释放或无法释放</strong>，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 </p>
</blockquote>
<h3>二、方法区的内部结构</h3>
<ol>
<li><p>方法区用于存储已被虚拟机加载的<strong>类型信息（包含域信息、方法信息）、常量、静态变量、即时编译器编译后的代码缓存</strong>等。</p>
</li>
<li><p>类型信息：对每个加载的类型（类class、接口interface、枚举enum、注解annotation)，JVM必须在方法区中存储以下类型信息：</p>
<ul>
<li>这个类型的<strong>完整有效名称</strong>（全名=包名.类名)</li>
<li>这个类型<strong>直接父类的完整有效名</strong>（对于interface或是java.lang.object，都没有父类）</li>
<li>这个类型的<strong>修饰符</strong>（public,abstract, final的某个子集）</li>
<li>这个类型直接接口的一个有序列表</li>
<li><strong>域信息、方法信息</strong></li>

</ul>
</li>
<li><p>域信息（属性信息），即类中属性的相关信息</p>
<pre><code>public int num;
	descriptor: I; // int类型
	flags: ACC_PUBLIC // public修饰
private static java.lang.String str;
	descriptor: Ljava/lang/String; // String类
	flags: ACC/PRIVATE, ACC_STATIC // public static
	
public static final int number;
	descriptor: I; // int类型
	flags: ACC_PUBLIC, ACC_STATIC, ACC_FINAL // public static final
	ConstantValue: int 2 // final static变量，在编译期直接赋值
</code></pre>
<pre><code class='language-java' lang='java'>public class MethodAreaTest {
    public static void main(String[] args) {
        // 即使是空指针，但指向的属性已经存放在方法区，因此不会报异常
        Order order = null;
        order.hello();
        System.out.println(order.number);
    }
 
}
class Order {
    // 静态变量
    public static int count = 1;
    // 静态final变量
    public static final int number = 2;
    // 静态方法
    public static void hello() {
        System.out.println(&quot;hello!&quot;);
    }
}
</code></pre>
<p>&nbsp;</p>
</li>
<li><p>方法信息，即类中方法的相关信息</p>
</li>
<li><p>运行时常量池 VS 常量池</p>
<ul>
<li>方法区，内部包含了运行时常量池</li>
<li>字节码文件，内部包含了常量池</li>
<li>要弄清楚方法区，需要理解清楚ClassFile，因为加载类的信息都在方法区</li>

</ul>
</li>
<li><p>常量池表</p>
<ul>
<li>常量池可以看作一张表，虚拟机指令根据这张表找到要执行的类名、方法名、参数类型、字面量等类型</li>

</ul>
</li>
<li><p>运行时常量池的理解</p>
<ul>
<li>运行时常量池是方法区的一部分</li>
<li>常量池表是Class文件的一部分，<strong>用于存放编译期生成的各种字面量域符号引用</strong>，<strong>这部分内容将在类加载后存放到方法区的运行时常量池中</strong>。</li>
<li>运行时常量池，在加载类和接口到虚拟机后，就会创建对应的运行时常量池。</li>
<li>JVM为每个已加载的类型（类和接口）都维护一个常量池。池中的数据项类似于数组项，是<strong>通过索引访问</strong>的。</li>
<li>运行时常量池中包含多种不同的变量，包括<strong>编译期</strong>就已经明确的<strong>数值字面量</strong>，也包括到运行期解析后才能够获得的方法或者字段引用。此时不再是常量池中的符号地址了，而是转换为<strong>真实地址</strong>。</li>

</ul>
</li>
<li><p>方法区的演进细节：JDK6 -&gt; JDK7 -&gt; JDK8
<img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612499424380.png" referrerpolicy="no-referrer" alt="1612499424380"></p>
</li>
<li><p>方法区的更新换代</p>
<ul>
<li>JDK6：静态变量引用与运行时常量池都存放在永久代中，且字符串常量池存放在运行时常量池中。</li>
<li>JDK7：保留永久代，<strong>静态变量（变量引用）与字符串常量池转移到堆Heap中存放</strong>。</li>
<li><strong>JDK8</strong>：去除永久代，方法区的具体实现由<strong>永久代转为元空间（MetaSpace）</strong>，且分配在本地内存中，不在虚拟机内存范围内，因此元空间大小只受限于实际物理计算机的内存大小。</li>

</ul>
</li>
<li><p>字符串常量池</p>
<ul>
<li><p><strong>为什么将字符串常量池从方法区转移到堆空间</strong>？</p>
<ul>
<li>由于永久代与老年代触发Full GC的频率较低，如果存放在方法区中，则会导致字符串常量池被回收的概率不高，而开发中会有大量的字符串被创建，回收效率低会导致永久代内存不足。放在堆中则能及时被回收。</li>

</ul>
</li>

</ul>
</li>
<li><p>关于静态变量存放位置的说明</p>
<ul>
<li><strong>类中的静态属性的对象实体，始终存放在堆中。</strong></li>
<li>JDK7中的静态变量位置转移指的是<strong>静态变量名</strong>的转移。</li>
<li>JDK7后HotSpot虚拟机选择把静态变量名与该变量映射的Class对象实体都存放在堆空间中。</li>

</ul>
</li>
<li><p>方法区的垃圾收集</p>
<ul>
<li><strong>方法区的垃圾收集主要回收两部分内容：常量池中废弃的常量和不再使用的类型</strong></li>

</ul>
</li>

</ol>
<h2>V 对象的实例化</h2>
<h3>一、创建对象的方式</h3>
<ol>
<li><p>new的方式或变形</p>
<ul>
<li>普通的new对象</li>
<li>变形1：单例中的getInstance()方法</li>
<li>变形2：通过某种类对应的Builder类或Factory类获取对象</li>

</ul>
</li>
<li><p>Class的newInstance()</p>
<ul>
<li>是一种通过反射的方式，只能调用空参的构造器，且该构造函数的访问权限必须是public</li>

</ul>
</li>
<li><p>Constructor的newInstance()</p>
<ul>
<li>也是一种反射的方式，可以调用空参或带参的构造器，权限没有要求</li>

</ul>
</li>
<li><p>使用clone()</p>
<ul>
<li>不调用构造器，获取的类必须实现Cloneable接口，实现clone()方法</li>

</ul>
</li>
<li><p>使用反序列化</p>
<ul>
<li>从文件或网络中获取对象的二进制文件</li>

</ul>
</li>

</ol>
<h3>二、创建对象的步骤</h3>
<ol>
<li><p>判断对象对应的类是否加载、链接、初始化</p>
<ul>
<li>要加载一个类对应的对象，则该类必须已经使用双亲委派机制加载到方法区中，并进行初始化。虚拟机遇到一个new指令时，需要检查该指令的参数能否在MetaSpace（方法区）的常量池中定位到一个类的符号引用。</li>

</ul>
</li>
<li><p>为对象分配内存</p>
<ol>
<li>如果内存规整，使用指针碰撞分配内存</li>
<li>如果内存不规整，虚拟机需要维护一个可用内存空闲列表</li>

</ol>
</li>
<li><p>处理并发问题</p>
<ol>
<li>采用CAS失败重试、区域加锁保证更新的原子性</li>
<li>每个线程先分配一块TLAB</li>

</ol>
</li>
<li><p>初始化分配的空间</p>
<ol>
<li>所有属性设置<strong>默认值</strong>，保证对象实例字段在不赋值时可以直接使用</li>

</ol>
</li>

</ol>
<blockquote><p>给对象赋值的操作：属性的默认初始化——显式初始化——代码块中的初始化——构造器中的初始化</p>
</blockquote>
<ol start='5' >
<li>设置对象的对象头</li>
<li>执行init方法进行初始化</li>

</ol>
<h3>三、内存布局</h3>
<ol>
<li><p>对象头（Header）</p>
<ul>
<li><p>运行时元数据</p>
<ul>
<li>哈希值，即地址值</li>
<li>GC分代年龄</li>
<li>锁状态标志</li>
<li>线程持有的锁</li>
<li>偏向线程ID、偏向时间戳</li>

</ul>
</li>
<li><p><strong>类型指针：指向类元数据InstanceKlass，确定对象所属的类型</strong></p>
</li>
<li><p>如果是数组，还需要一个数组长度</p>
</li>

</ul>
</li>
<li><p>实例数据（Instance Data）</p>
<ol>
<li><p><strong>实例数据是对象真正的有效信息</strong>，包括程序代码中定义的各种类型的字段（包括从父类继承下来的和本身拥有的字段）</p>
</li>
<li><p>数据存放的规则</p>
<ul>
<li>相同宽度的字段放在一起</li>
<li>父类定义的变量出现在子类之前</li>
<li>子类的窄变量可能插入父类变量的空隙</li>

</ul>
</li>

</ol>
</li>
<li><p>对齐填充：用于堆空间的对齐</p>
</li>
<li><p><strong>方法栈、堆空间、方法区之间的联系</strong></p>
<pre><code class='language-java' lang='java'>public static void main(String[] args) {
	Customer cust = new Customer();	
}
class Customer {
    int id;
    String name;
    Account acct;
}
</code></pre>
<p>&nbsp;</p>
<p><img alt="1612612504665" src="D:\StudyDocument\MarkDown图片\1612612504665.png" data-src="D:\StudyDocument\MarkDown图片\1612612504665.png" onerror="this.style.display = 'none';"></p>
</li>

</ol>
<h3>四、对象的访问定位</h3>
<ol>
<li>使用句柄池的方式<img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612617338416.png" referrerpolicy="no-referrer" alt="1612617338416"></li>
<li><strong>直接引用方式</strong>（<strong>HotSpot使用的方式</strong>）</li>

</ol>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612617695648.png" referrerpolicy="no-referrer" alt="1612617695648"></p>
<h2>Ⅵ 直接内存（Direct Memory）</h2>
<ol>
<li><p><strong>不是虚拟机运行时数据区的一部分</strong>，也不是《Java虚拟机规范》中定义的内存区域</p>
</li>
<li><p>直接内存是在Java堆之外的，<strong>直接向系统申请的内存区间</strong>。</p>
</li>
<li><p>通常，访问直接内存的速度会优于Java堆，即读写性能高。</p>
<ul>
<li>Java的NIO库允许Java程序使用直接内存，用于IO操作的<strong>数据缓冲区</strong>。</li>

</ul>
</li>

</ol>
<h2>Ⅶ 执行引擎</h2>
<ol>
<li>执行引擎是Java虚拟机的核心之一。</li>
<li>执行引擎的任务就是<strong>将字节码指令解释/编译为对应平台上的本地机器指令</strong></li>

</ol>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612669879151.png" referrerpolicy="no-referrer" alt="1612669879151"></p>
<ol start='3' >
<li><p>Java代码编译和执行的过程</p>
<ul>
<li>解释器：当Java虚拟机启动时会根据预定义的规范<strong>对字节码采用逐行解释的方式执行</strong>，将每条字节码文件中的内容“翻译”为对应平台的本地机器指令执行。</li>
<li>JIT（Just In Time Compiler）编译器：<strong>虚拟机将源代码直接编译成和本地相关平台的机器语言</strong>。</li>

</ul>
</li>

</ol>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612670698978.png" referrerpolicy="no-referrer" alt="1612670698978"></p>
<ol start='4' >
<li><p>JIT编译期与解释器的相互协作</p>
<ul>
<li>当虚拟机启动时，<strong>解释器可以先发挥作用</strong>，不必等待即时编译器全部编译完成再执行，这样可以省去很多不必要的编译时间。并且<strong>随着程序运行时间的推移，即时编译器逐渐发挥作用</strong>，根据<strong>热点探测</strong>功能，<strong>将有价值的字节码编译为本地机器指令</strong>，以换取更高的执行效率。</li>

</ul>
</li>
<li><p>热点探测方式</p>
<ul>
<li>目前HotSpot Vm所采用的<strong>热点探测方式是基于计数器的热点探测。</strong></li>

</ul>
</li>
<li><p>方法调用时所采用的方式——解释执行 / 执行机器码</p>
</li>

</ol>
<blockquote><p>通过方法计数来决定<strong>此次方法调用的执行方式</strong>——解释执行或直接执行机器码，如果计数到达阈值，则<strong>本次方法调用仍使用解释执行</strong>，随后将该方法编译成机器码，下次使用时则直接执行机器码。</p>
</blockquote>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612671809612.png" referrerpolicy="no-referrer" alt="1612671809612"></p>
<ol start='7' >
<li><p><strong>关于热度衰减</strong></p>
<ul>
<li>如果不做任何设置，方法调用计数器统计的并不是方法被调用的绝对次数。而是一个相对的频率，即一段时间被调用的次数。当超过一定的时间限度，如果方法的调用次数仍然不足以提交给即时编译器编译，那么这个方法的调用计数器就会<strong>减少一半</strong>，这个过程称为<strong>方法调用计数器热度的衰减</strong>，而这<strong>段时间称之为半衰周期</strong>。</li>

</ul>
</li>

</ol>
<h2>Ⅶ StringTable</h2>
<h3>一、String的基本特性</h3>
<ol>
<li>字符串用英文的双引号 &quot;&quot; 引起来表示</li>
<li>String声明为final类，<strong>不可被继承</strong></li>
<li>String实现了 Serializable接口，表示字符串是<strong>支持序列化</strong></li>
<li>String实现了Comparable接口，表示字符串<strong>可以比较大小</strong></li>
<li>在jdk8之前定义了final char[ ] value用于存储字符串，jdk9后改为byte[ ]</li>

</ol>
<blockquote><p>在jdk9之前，使用char数组时，不管是何种字符，都使用2个字节来存储，但经过调查统计发现，大部分的字符串使用的是拉丁文与英文（仅需要一个字节来存储），这会造成大量的空间被浪费。因此，在jdk9后改为使用byte数组来存储字符串，且根据字符串中的内容来改变一个字符占用1个或2个字节。</p>
</blockquote>
<ol start='6' >
<li><p><strong>不可变性</strong></p>
<ol>
<li>对字符串重新赋值时，需要重写指定内存区域赋值，不能使用原有的value赋值</li>
<li>当对现有字符进行拼接操作时，也需要重新指定内存区域赋值，不能使用原有的value赋值。</li>
<li>当调用replace()修改指定字符或字符串时，也需要重新赋值</li>

</ol>
</li>
<li><p>通过字面量的方式，即<code>String str = &quot;something&quot;</code>，此时<strong>字符串的值声明在字符串常量池中</strong>。</p>
</li>
<li><p><strong>字符串常量池中不会存储相同内容的字符串</strong></p>
</li>
<li><p>String Pool的底层HashTable的结构说明</p>
<ol>
<li>StringPool是一个<strong>固定大小的Hash Table</strong>，<strong>实现方式是数组+链表</strong>，默认大小是1009。如果放进的String过多，就会造成<strong>Hash冲突</strong>，从而导致<strong>链表变长</strong>，从而<strong>导致String.intern时性能会大幅下降</strong></li>
<li>使用<strong>-XX:StringTableSize</strong>可设置StringTable的长度</li>
<li>jdk6中的Table长度默认值是1009</li>
<li>dk7中的Table长度默认值是60013，且1009是最小值</li>

</ol>
</li>

</ol>
<h3>二、String的内存分配</h3>
<ol>
<li><strong>Java 6之前，字符串常量池存放在永久代。</strong></li>
<li><strong>Java 7后字符串常量池存放在堆空间</strong></li>
<li><mark><strong>StringTable存放的也是String对象</strong></mark></li>

</ol>
<h3>三、String的基本操作</h3>
<pre><code class='language-java' lang='java'>public static void main(String[] args) {
    // 当前字符串常量池还没有创建以下字符，因此每次调用都有增加常量池中对象个数
    // JVM会加载&quot;1&quot;到&quot;4&quot;
    System.out.println(&quot;1&quot;);
    System.out.println(&quot;2&quot;);
    System.out.println(&quot;3&quot;);
    System.out.println(&quot;4&quot;);

	// 由于当前字符串常量池已经有对应的字符串，因此以下代码会直接使用常量池中的字符串
    // jvm不会加载&quot;1&quot;到&quot;4&quot;
    System.out.println(&quot;1&quot;);
    System.out.println(&quot;2&quot;);
    System.out.println(&quot;3&quot;);
    System.out.println(&quot;4&quot;);
}
</code></pre>
<p>&nbsp;</p>
<pre><code class='language-java' lang='java'>public static void main(String[] args) {
    int i = 1;
    Object obj = new Object();
    Memory mem = new Memory();
    mem.foo(obj);
}

private void foo(Object param) {
    String str = param.toString();
    System.out.println(str);
}
</code></pre>
<p>以上代码对应的内存结构如下：</p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1612884034853.png" referrerpolicy="no-referrer" alt="1612884034853"></p>
<h3>四、字符串的拼接操作</h3>
<ol>
<li><p><strong>字符串常量与常量的拼接结果在常量池</strong>，原理是<strong>编译器优化</strong>，例如：</p>
<pre><code class='language-java' lang='java'>String str = &quot;a&quot; + &quot;b&quot; + &quot;c&quot;;

// 以上代码会被编译器优化为以下结果
String str = &quot;abc&quot;
</code></pre>
</li>
<li><p>常量池中不会存在相同内容的常量</p>
</li>
<li><p>拼接时<strong>只要其中有一个是变量</strong>，返回的引用结果<strong>不在常量池中</strong>，但<strong>仍在堆中</strong>。相当于在堆空间中new String()，变量拼接的原理是StringBuilder，例如：</p>
<pre><code class='language-java' lang='java'>String s1 = &quot;yu&quot;;
String s2 = &quot;zhijie&quot;;
String s3 = &quot;yuzhijie&quot;;

String s4 = s1 + s2;
String s5 = &quot;yu&quot; + &quot;zhijie&quot;;
String s6 = s4.intern();
System.out.println(s3 == s4); // false，由于s1和s2是变量，所以s4指向常量池外的对象
System.out.println(s3 == s5); // true，因为s5是由两个常量拼接，因此和s3一样指向常量池中的值
System.out.println(s3 == s6); // true，调用intern方法后，返回
</code></pre>
</li>
<li><p><strong>如果拼接的结果调用intern()方法，则主动在常量池中还没有的字符串对象放入池中，并返回此对象的地址</strong></p>
</li>
<li><p>String在拼接的细节实现</p>
<pre><code class='language-java' lang='java'>String s4 = s1 + s2;

// jvm用String Builder来实现拼接
StringBuilder s = new StringBuilder();
s.append(&quot;yu&quot;);
s.append(&quot;zhijie&quot;);
s.toString() // --&gt; 约等于new String();
</code></pre>
</li>
<li><p>intern方法的说明</p>
<ol>
<li><p>intern方法会从当前字符串常量池中<strong>查询当前字符串是否存在</strong>，<strong>若不存在</strong>，则会<strong>将当前的字符串放入常量池中</strong>，并返回该字符串的地址</p>
</li>
<li><p>如何保证得到的变量一定是字符串常量池中的数据</p>
<ul>
<li>字面量定义：<code>String str = &quot;yuzhijie&quot;<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>;</span></code> </li>
<li>使用intern方法：<code>String str = new String(&quot;yuzhijie&quot;).intern()<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>;</span></code></li>

</ul>
</li>
<li><p>常见面试题</p>
<ol>
<li><p>new String(&quot;ab&quot;)会创建几个对象</p>
<ul>
<li>答案是两个；在字符串常量池中创建&quot;ab&quot;，在堆空间中创建String实例，内容为&quot;ab&quot;</li>

</ul>
</li>
<li><p><strong>new String(&quot;a&quot;) + new String(&quot;b&quot;)又会创建几个对象</strong></p>
<ul>
<li><strong>答案是六个</strong>；一是用于拼接用的String Builder，第二个是new的String类”a&quot;，以及字符串常量池中的&quot;a&quot;，同理new String(&quot;b&quot;)以及字符串常量池中的&quot;b&quot;，第六个是toString方法中new String()的对象。<strong>要注意，toString()方法不会在字符串常量池中创建字符串</strong>，因为toString方法调用了<code>new String(new String(char[] value, int offset, int count)</code>方法，即直接创建一个String对象，并给其char数组赋值，没有在字符串常量池中创建</li>

</ul>
</li>

</ol>
</li>
<li><p>jdk6与jdk7/8的intern方法的差别</p>
</li>

</ol>
<ul>
<li><p>如果常量池中有对应的字符串，直接返回该引用。</p>
</li>
<li><p>如果常量池和堆中没有对应的字符串：使用intern方法，则JVM都会在常量池中添加该字符串并返回该引用。</p>
</li>
<li><p>如果堆中已经有该字符串，调用intern方法：</p>
<ul>
<li>在jdk6中，jvm仍然会在字符串常量池中创建该字符串，并返回该引用</li>
<li><strong>在jdk7/8中，JVM会在字符串常量池中创建指向堆中已存在的该字符串的引用，并返回常量池中的引用。</strong></li>

</ul>
</li>

</ul>
</li>

</ol>
<h2>Ⅷ 垃圾回收</h2>
<h3>一、什么是垃圾</h3>
<ol>
<li>垃圾是指<strong>运行程序中没有任何指针指向的对象</strong>，这个对象就是需要被回收的垃圾</li>

</ol>
<blockquote><p>原文：An Object is considered garbage when it can no longer be reached from any pointer in the running program.</p>
</blockquote>
<h3>二、为什么需要GC</h3>
<ol>
<li>内存迟早会消耗完，如果不进行GC，那么程序就会占据大量空间而浪费内存。</li>
<li>JVM可以将整理出的内存分配给新的对象，即清楚内存里的碎片</li>
<li>没有GC不能保证Java应用程序正常进行</li>

</ol>
<h3>三、Java垃圾回收机制</h3>
<ol>
<li><p>自动内存管理，降低内存泄漏与内存溢出的风险</p>
</li>
<li><p>Java堆是垃圾收集器的工作重点。</p>
</li>
<li><p>从次数上讲：</p>
<ul>
<li>频繁收集Young区</li>
<li>较少收集Old区</li>
<li>几乎不收集Perm区（元空间）</li>

</ul>
</li>

</ol>
<h3>四、垃圾回收算法</h3>
<ol>
<li><p>标记阶段：对象存活判断</p>
<ol>
<li><p>垃圾收集之前需要先明确内存中哪些是存活对象，哪些是已死亡的对象，这个过程叫做<strong>垃圾标记阶段</strong>。</p>
</li>
<li><p>标记算法之引用计数算法</p>
<ul>
<li><p><strong>每个对象保存一个整形的引用计数器属性，用于记录对象被引用的情况。</strong></p>
</li>
<li><p>例如：一个对象a，只要有任何一个对象引用了a，那么a的引用计数器就加1，引用失效就减1。当对象a的引用计数器为0，说明对象a不可能再被引用，可进行回收。</p>
</li>
<li><p>优点：实现简单，效率高</p>
</li>
<li><p>缺点：</p>
<ul>
<li>需要单独的字段存储计数器，内存开销变大。频繁加减，时间开销也变大</li>
<li><strong>最致命的缺点是无法处理循环引用的情况</strong>：如果堆中两个对象互相引用，那么这两个对象的计数器都是1，即使这两个对象是垃圾也无法进行垃圾回收。</li>

</ul>
</li>

</ul>
</li>
<li><p>标记算法之<strong>可达性分析算法</strong>（也叫根搜索算法、追踪性垃圾收集，是JVM实际采用的算法）</p>
<ol>
<li><p><strong>关键：能够解决循环引用问题</strong></p>
</li>
<li><p>基本思路：</p>
<ol>
<li>以<strong>根对象集合</strong>（GC Roots）为起始点，<strong>按照从上至下的方式搜索被根对象集合所连接的目标对象是否可达</strong></li>
<li>使用可达性分析算法后，内存中存活的对象都会被根对象集合直接或间接连接着，搜索所走过的路径称为<strong>引用链</strong></li>
<li>如果目标对象没有任何引用链相连，则是不可达的，意味着该对象已死亡，可以标记为垃圾对象</li>

</ol>
</li>
<li><p>根对象集合GC Roots包括以下元素：</p>
<ul>
<li>虚拟机栈中引用的对象，比如各个线程中被调用的方法中使用到的参数、布局变量等。</li>
<li>本地方法栈内JNI，即本地方法引用的对象</li>
<li>方法区中类静态属性引用的对象</li>
<li>方法区中常量引用的对象，例如字符串常量池里的引用</li>
<li>所有被synchronized持有的对象，例如<code>synchronized(obj)<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>;</span></code></li>
<li>JVM内部的引用</li>
<li>反映JVM内部情况的JMXBean、JVMTI中注册的回调、本地方法缓存等</li>

</ul>
</li>
<li><p><strong>如果要使用可达性分析算法判断内存是否可回收，那么分析工作必须在一个能保障一致性的快照中进行</strong>，即进行可回收分析时，必须暂停其他用户进程以保证分析结果的准确性</p>
</li>
<li><p>对象的finalization机制</p>
<ol>
<li><p>Java语言提供了对象终止机制来<strong>允许开发人员提供对象销毁之前的自定义逻辑处理</strong></p>
</li>
<li><p><strong>当垃圾收集器回收对象时，总会先调用这个对象的finalize()方法</strong></p>
</li>
<li><p>finalize方法访问权限是protected，允许被子类重写，用于在对象被回收时进行资源释放。</p>
</li>
<li><p><strong>永远不要主动调用某个对象的finalize方法</strong>，可能会导致程序错误</p>
<ol>
<li><p><strong>对象的finalize方法在其生命周期中只能被调用一次</strong></p>
</li>
<li><p>由于finalize方法的存在，<strong>虚拟机中的对象一般处于三种可能的状态</strong></p>
<ol>
<li>可触及的：从根节点开始，可以到达该对象</li>
<li>可复活的：对象的所有引用都被释放，但是对象有可能在finalize()中复活</li>

</ol>
</li>

</ol>
</li>
<li><p>不可触及的：对象的finalize方法被调用，并且没有复活</p>
</li>

</ol>
</li>
<li><p>判断一个对象是否需要回收，<strong>至少需要进行两次标记过程</strong>：</p>
<ol>
<li><p>如果对象obj到GC Roots没有引用链，则进行<strong>第一次标记</strong></p>
</li>
<li><p>判断此对象是否需要进行finalize方法</p>
<ol>
<li>如果<strong>没有重写finalize方法</strong>，或者<strong>该方法已被虚拟机调用过</strong>，那么判定为<strong>不可触及</strong></li>
<li>obj<strong>重写了finalize方法</strong>，<strong>且还未执行过</strong>，那么<strong>将该对象插入F-Queue队列中</strong>，由一个低级别的Finlizer线程执行该方法</li>

</ol>
</li>
<li><p><strong>finalize方法是对象逃脱死亡的最后机会</strong>，GC在F-Queue队列中进行第二次标记，如果obj在finalize方法中与引用链建立的联系，那么将会被移除“即将被回收”集合。<strong>在之后再次出现没有引用的情况下，不会再考虑finalize，而是直接标记为不可触及状态</strong></p>
</li>

</ol>
<pre><code class='language-java' lang='java'>public class FinalizeTest {
    public static FinalizeTest obj;

    // 重写finalize方法
    @Override
    protected void finalize() throws Throwable {
        super.finalize();
        System.out.println(&quot;复活！&quot;);
        obj = this;
    }

    public static void main(String[] args) {
        try {
            // 创建对象
            obj = new FinalizeTest();
            // 对象失去引用
            obj = null;
            // 调用GC
            System.gc();
            // 等待线程进行GC，并调用finalize()方法
            Thread.sleep(1000);

            // 判断对象是否救活
            if (obj == null) {
                System.out.println(&quot;obj is dead for first time&quot;);
            } else {
                System.out.println(&quot;obj is lived for first time&quot;);
            }

            // 如果救活，进行第二次测试
            obj = null;
            // 调用GC
            System.gc();
            // 等待线程进行GC，并调用finalize()方法-&gt;但此次并不会调用finalize()方法
            Thread.sleep(1000);

            // 判断对象是否救活
            if (obj == null) {
                System.out.println(&quot;obj is dead for second time&quot;);
            } else {
                System.out.println(&quot;obj is lived for second time&quot;);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre>
</li>

</ol>
</li>
<li><p>垃圾清除阶段</p>
<ol>
<li><p>标记-清除算法（Mark-Sweep）</p>
<ol>
<li><p>标记Mark：Collector从引用根节点开始遍历，<strong>标记所有被引用的对象</strong>。一般是在对象的对象头（Header）中记录为可达对象。</p>
</li>
<li><p>清除Sweep：Collector<strong>对堆内存从头到尾进行线性遍历</strong>，如果发现某个对象在其Header中没有标记为可达对象，则进行回收。 </p>
</li>
<li><p>缺点：</p>
<ul>
<li><strong>效率低</strong></li>
<li>进行GC时需要停止整个应用程序</li>
<li>清理后的<strong>空闲内存不连续</strong>，产生<strong>内存碎片</strong>，需要维护一个空闲列表</li>

</ul>
</li>
<li><p><strong>何为清除</strong></p>
<ul>
<li>这里的清除<strong>并不是指真的置空</strong>，而是把需要清除的对象地址保存在空闲的地址列表里。</li>

</ul>
</li>

</ol>
</li>
<li><p>复制算法（Copying）</p>
<ol>
<li><p>核心思想：<strong>将活着的内存空间分成两块，每次只是用其中一块</strong>，在垃圾回收时<strong>将正在使用的内存的存活对象复制到另一半内存空间中</strong>，之后清除正在使用的所有对象，<strong>交换两个内存的角色</strong>，最后完成垃圾回收。</p>
</li>
<li><p>优点</p>
<ul>
<li>没有标记和清除过程，实现简单，<strong>运行高效</strong></li>
<li>复制过去后<strong>保证空间的连续性</strong>，不会出现碎片问题</li>

</ul>
</li>
<li><p>缺点</p>
<ul>
<li>由于只使用一半的内存，因此内存空间要求是普通的两倍</li>
<li>对于G1这种拆分成大量的region的GC，复制而不是移动，<strong>意味着GC要维护region之间对象的引用关系</strong>，不管是内存占用</li>
<li>特别的，如果系统的垃圾对象很多，复制算法需要复制的存活对象并不会太大。但如果进行GC时，大多数对象都是存活的，那么需要复制的对象就大大增加，甚至可能全部都要复制一遍。</li>

</ul>
</li>
<li><p>应用场景 </p>
<ul>
<li><strong>在新生代中</strong>，对常规应用的垃圾回收，<strong>一次通常回收70%~90%的内存空间</strong>。回收性价比很高，所以<strong>现在的商业虚拟机都是使用这种垃圾收集算法回收新生代</strong></li>

</ul>
</li>

</ol>
</li>
<li><p>标记-压缩算法（整理）算法</p>
<ul>
<li>即在进行标记收集算法后，进行内存规整化。</li>

</ul>
</li>

</ol>
</li>
<li><p>分代收集算法</p>
<ul>
<li><p><strong>不同的对象生命周期都不一样</strong>。因此，<strong>不同生命周期的对象可以采取不同的收集方式</strong>，以便提高回收效率。一般是<strong>把堆分为新生代和老年代</strong>，这样就可以<strong>根据各个年代的特点使用不同的回收算法</strong>，以提高垃圾回收的效率</p>
<ul>
<li>以HotSpot中的CMS回收期为例，CMS是基于Mark-Sweep实现的，对于对象的回收效率很高。再采用Mark-Compact算法的Serial Old回收期作为补偿措施。</li>

</ul>
</li>

</ul>
</li>
<li><p>增量收集算法</p>
<ol>
<li><p>基本思想</p>
<ul>
<li>如果一次性将所有的垃圾进行处理，需要造成系统长时间的停顿，那么就可以让垃圾收集线程和应用程序线程交替进行。每次，<strong>垃圾收集线程只收集一小片区域的内存空间</strong>，接着切换到应用程序线程。以此反复，直到垃圾收集完成。</li>
<li>缺点：造成系统吞吐量下降。</li>

</ul>
</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3>五、垃圾回收相关概念</h3>
<ol>
<li><p>System.gc()的理解</p>
<ol>
<li>在默认情况下，通过System.gc()或者Runtime.getRuntime.gc()的调用，<strong>会显示触发Full GC</strong>，<strong>同时对老年代和新年代进行回收</strong>，尝试释放被丢弃对象占用的内存。</li>
<li><strong>但System.gc()的调用无法保证对垃圾收集器的调用</strong>。</li>
<li>一般情况下，垃圾回收应该是自动进行的，<strong>无须手动触发</strong>。</li>

</ol>
</li>
<li><p>内存溢出（OOM）</p>
<ul>
<li>javadoc对OOM的解释是：没有空闲内存，并且垃圾回收也无法提供更多的内存</li>

</ul>
</li>
<li><p>STW——Stop The World</p>
<ul>
<li>指的是GC事件发生过程中，会产生应用程序的卡顿。<strong>停顿产生时整个应用程序线程都会被暂停，没有任何响应</strong>。</li>
<li>STW事件与采用哪款GC无关，<strong>所有的GC都有这个事件</strong>。</li>
<li>STW是JVM<strong>在后台自动发起和自动完成的</strong>，在用户不可见的情况下，把用户的工作线程全部停掉</li>

</ul>
</li>
<li><p><strong>垃圾回收中</strong>并行与并发的概念</p>
<ul>
<li><p>并行：指<strong>多条垃圾回收线程并行工作</strong>，但此时<strong>用户线程</strong>仍处于<strong>等待状态</strong>。</p>
</li>
<li><p>串行</p>
<ul>
<li>是相较于并行的概念</li>
<li>如果内存不够，则<strong>程序暂停</strong>，启动JVM垃圾回收器进行垃圾回收。<strong>回收完再启动用户程序的线程</strong></li>

</ul>
</li>
<li><p>并发：指用户线程与垃圾收集线程同时执行，<strong>垃圾回收线程在执行时不会停顿用户程序的运行</strong>。</p>
<ul>
<li>用户程序继续执行，而垃圾收集程序线程运行于另一个CPU上</li>

</ul>
</li>

</ul>
</li>

</ol>
<ul>
<li>如CMS，G1</li>

</ul>
<ol start='5' >
<li><p>安全点与安全区域</p>
<ul>
<li><p>程序在执行时，并非在所有地方都能停顿下来开始GC，<strong>只有特定的位置才能停顿下来开始GC</strong>，这些位置称为<strong>安全点(Safe Point)</strong></p>
</li>
<li><p>安全点的选择很重要，如果太少可能导致GC等待的时间太长，如果太多可能导致运行性能低</p>
</li>
<li><p>通常会根据“是否能让程序长时间执行的特征”为标准，选择一些执行时间较长的指令，如方法调用、循环跳转等</p>
</li>
<li><p>那么如何保证在GC发生时，检查所有的线程都运行到安全点停顿下来呢？</p>
<ul>
<li>抢先式中断（目前无虚拟机采用）：首先中断所有线程，如果有线程不在安全点，就恢复线程，让线程运行到安全点。</li>
<li><strong>主动式中断</strong>：设置一个中断标志，各个线程运行到安全点的时候主动轮询这个标志，如果中断标志为真，则将进行中断挂起。</li>

</ul>
</li>
<li><p>安全区域（Safe Region）是指在一段代码片段中，对象的引用关系不会发生变化，在这个区域中的任何位置开始GC都是安全的。安全区域可以视为安全点的扩展。</p>
</li>

</ul>
</li>
<li><p>强引用——不回收</p>
<ol>
<li>在Java程序中，最常见的就是强引用（<strong>普通系统99%都是强引用</strong>），是默认的一种引用类型。</li>
<li>强引用对象是可触及的，<strong>垃圾收集器永远不会回收被强引用的对象</strong></li>
<li>强引用是造成Java内存泄漏的主要原因之一</li>

</ol>
</li>
<li><p>软引用——内存不足即回收</p>
<ol>
<li>软引用用来描述一些还有用但不是必需的对象。只被软引用关联的对象，在系统将<strong>要发生内存泄漏异常之前</strong>，会把这些对象列进回收范围之中进行<strong>第二次回收</strong>，如果此次回收仍没有足够的内存，才抛出内存溢出异常</li>
<li>软引用通常用来实现内存敏感的缓存。比如<strong>高速缓存</strong>就有用到软引用，<strong>如果还有空闲内存，就可以暂时保留缓存</strong>，<strong>当内存不足时就清理掉</strong>，这样就可以保证使用了缓存的同时，不会耗尽内存</li>
<li>代码实例</li>

</ol>
<pre><code class='language-java' lang='java'>public class SoftReferenceTest {
    public static void main(String[] args) {
        Object obj = new Object();
        SoftReference&lt;Object&gt; sf = new SoftReference&lt;&gt;(obj);
        // 使堆中的对象失去强引用
        obj = null;
        // 使用get()方法获取软引用指向的对象
        System.out.println(sf.get());
    }
} 
</code></pre>
</li>
<li><p>弱引用——发现即回收</p>
<ol>
<li>只被弱引用关联的对象，在GC时<strong>一旦发现则直接进行回收</strong></li>
<li>代码示例</li>

</ol>
<pre><code class='language-java' lang='java'>public class WeakReferenceTest {
    public static void main(String[] args) {
        Object obj = new Object();
        WeakReference&lt;Object&gt; sf = new WeakReference&lt;&gt;(obj);
        // 使堆中的对象失去强引用
        obj = null;
        // 使用get()方法获取弱引用指向的对象
        System.out.println(sf.get());
    }
}
</code></pre>
</li>
<li><p>虚引用——对象回收跟踪</p>
<ol>
<li>也称为“幽灵引用”或“幻影引用”，是所有引用类型中最弱的一个。</li>
<li>一个对象是否存在虚引用的存在，完全不会决定对象的生命周期。<strong>如果对象只有一个虚引用，约等于没有引用。</strong></li>
<li>使用方法不同于软引用和弱引用，<strong>不可以单独使用</strong>，使用get()方法获取到的总是null</li>
<li><strong>目的：为一个对象设置虚引用关联的唯一目的在于跟踪垃圾回收过程。比如能在某个对象被垃圾收集器回收时收到一条系统通知。</strong></li>

</ol>
</li>

</ol>
<h2>Ⅸ 垃圾回收器</h2>
<h3>一、GC分类与性能指标</h3>
<ol>
<li><p>垃圾回收期的分类</p>
<ol>
<li>按<strong>线程数</strong>分，可以分为串行垃圾回收器和并行垃圾回收器，即垃圾收集时GC线程为单线程或多线程</li>
<li>按<strong>工作模式</strong>来分，可以分为并发式垃圾回收器和独占式垃圾回收器，即GC时是否允许用户线程同时执行</li>
<li>按<strong>碎片处理方式</strong>分，可分为压缩式垃圾回收器和非压缩式垃圾回收器</li>
<li>按<strong>工作的内存空间</strong>来分，又可以分为年轻代垃圾回收器和老年代垃圾回收器</li>

</ol>
</li>
<li><p>评估GC的性能指标</p>
<ol>
<li><strong>吞吐量：运行用户代码的时间占总运行时间的比例</strong></li>
<li>垃圾收集开销：吞吐量的补数，垃圾收集所用时间与总运行时间的比例</li>
<li><strong>暂停时间：执行垃圾收集时，程序的工作线程被暂停的时间</strong></li>
<li>收集频率：相对于应用程序的执行，收集操作发生的频率</li>
<li><strong>内存占用：Java堆区所占内存的大小。</strong></li>
<li>快速：一个对象从诞生到被回收所经历的时间</li>

</ol>
</li>
<li><p>吞吐量</p>
<ol>
<li><p>吞吐量就是CPU<strong>用于运行用户代码的时间</strong>与<strong>CPU总消耗时间</strong>的比值</p>
</li>
<li><p>吞吐量 = 运行用户代码时间 / （运行用户代码时间  + 垃圾收集时间）</p>
</li>
<li><p>注重吞吐量：<strong>用户线程占比尽量大</strong></p>
<p><img src="file://D:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/MarkDown%E5%9B%BE%E7%89%87/1613449213372.png" referrerpolicy="no-referrer" alt="1613449213372"></p>
<ol>
<li>注重低延迟：用户线程与收集线程切换时间短，即<strong>用户线程的暂停时间短</strong></li>

</ol>
<p><img src="file://D:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/MarkDown%E5%9B%BE%E7%89%87/1613449352266.png" referrerpolicy="no-referrer" alt="1613449352266"></p>
</li>

</ol>
</li>

</ol>
<h3>二、经典垃圾收集器</h3>
<ol>
<li><p>7款垃圾收集器与垃圾分代之间的关系</p>
<ul>
<li>新生代收集器：Serial、ParNew、Parallel Scavenge</li>
<li>老年代收集器：Serial Old、Parallel Old、CMS</li>
<li>整代收集器：G1</li>

</ul>
</li>
<li><p>经典垃圾收集器的组合</p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1613452829417.png" referrerpolicy="no-referrer" alt="1613452829417"></p>
</li>
<li><p><strong>JDK8默认使用ParallelScavenge GC和Parallel Old GC组合</strong></p>
</li>
<li><p>查看默认垃圾收集器</p>
<ol>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:PrintCommandLineFlags</code> 运行时会打印出相关参数</p>
</li>
<li><p>或者使用命令行参数：jinfo -flag 相关垃圾收集器参数 进程ID</p>
<ul>
<li>例如查看1003进程是否使用G1垃圾收集器：<code>jinfo <span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>flag UserG1GC 1003</code></li>

</ul>
</li>

</ol>
</li>

</ol>
<h3>三、Serial回收器——串行回收</h3>
<ol>
<li><p>Serial收集器是最基本、历史最悠久的垃圾收集器。在jdk1.3之前回收新生代的唯一选择</p>
</li>
<li><p>Serial收集器作为HotSpot中Client模式下的默认新生代收集器</p>
</li>
<li><p><strong>Serial收集器采用复制算法、串行回收和“Stop The World”机制的方式执行内存回收</strong></p>
</li>
<li><p><strong>Serial Old收集器同样采用了串行回收和“Stop The World”机制，只不过内存回收算法采用了标记-压缩算法，用于收集老年代</strong></p>
</li>
<li><p>Serial Old在<strong>Server模式</strong>下主要有两个用途：</p>
<ol>
<li>与新生代Parallel Scavenge配合使用</li>
<li><strong>作为老年代CMS收集器的后备垃圾收集方案</strong></li>

</ol>
</li>

</ol>
<h3>四、ParNew回收器——并行回收</h3>
<ol>
<li><p><strong>ParNew收集器可以视为Serial收集器的多线程版本</strong></p>
<ul>
<li>Par是Parallel（并行）的缩写，<strong>New则表示只能收集新生代</strong></li>

</ul>
</li>
<li><p>仍然采用复制算法和 “Stop The World” 机制，不同的地方是<strong>支持多线程</strong></p>
</li>
<li><p>ParNew是很多JVM运行在Server模式下新生代的默认垃圾收集器</p>
</li>

</ol>
<h3>五、Parallel Scavenge回收器——吞吐量优先</h3>
<ol>
<li>与ParNew收集器相似，采用复制算法、“Stop The World” 机制和多线程</li>
<li>目的是为了达到<strong>可控制的吞吐量</strong>，也被称为<strong>吞吐量优先的垃圾收集器</strong></li>
<li><strong>自适应调节策略</strong>Parallel Scavenge和ParNew一个重要区别</li>
<li>主要<strong>适用于在后台计算而不需要太多用户交互的任务</strong>，因此<strong>常见在服务器环境中使用</strong></li>
<li>在jdk1.6后提供了Parallel Old收集器用来替代Serial Old单线程收集器，Parallel Old收集器采用了<strong>标记-压缩算法</strong>，但同样也是基于<strong>并行回收</strong>和 <strong>“Stop The World” 机制</strong></li>
<li><mark>JDK8默认的收集器</mark></li>

</ol>
<h3>六、Parallel Scavenge回收器的相关参数设置</h3>
<ol>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:+UseParallelGC</code> 手动指定使用Parallel收集器收集新生代、Parallel Old收集器收集老年代</p>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:+UseParallelOldGC</code> 手动指定使用Parallel收集器收集新生代、Parallel Old收集器收集老年代</p>
</li>
<li><p><strong>以上两个参数指令会互相激活另一个参数指令</strong></p>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:ParallelGCThreads</code> 设置年轻代并行收集器的线程数。一般的，<strong>最好与CPU数量（核数）相等</strong>，以免过多的线程数影响垃圾收集性能</p>
<ul>
<li>默认情况下，当CPU个数小于8个，ParallelGCThreads的值等于CPU个数</li>
<li>当个数大于8个，ParallelGCThreads的值等于3+(5 * CPU个数 / 8)</li>

</ul>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:MaxGCPauseMills</code> 设置垃圾收集器<strong>最大停顿时间</strong>（即STW时间），单位是ms。为了尽可能把停顿时间控制在设定参数时间内，收集器在工作时会调整Java堆大小或者其他一些参数</p>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:GCTimeRatio</code> 设置<strong>垃圾收集时间占总时间的比例为1 /  (N + 1)</strong>，用于<strong>衡量吞吐量的大小</strong></p>
<ul>
<li>取值范围（0，100）。默认值99，即1+(99 + 1) = 1 / 100，即垃圾回收时间不超过1%</li>

</ul>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:<span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>UseAdaptiveSizePolicy</code> 设置Parallel Scavenge回收器具有<strong>自适应调节策略</strong></p>
<ul>
<li><strong>在这种模式下，年轻代的大小、Eden和Survivor的比例、晋升老年代的对象年龄等参数会被自动调整，已达到在堆大小、吞吐量和停顿时间之间的平衡点</strong></li>

</ul>
</li>

</ol>
<h3>七、CMS收集器——低延迟</h3>
<ol>
<li><p>CMS：Concurrent-Mark-Sweep，是HotSpot虚拟机中第一款真正意义上的<strong>并发收集器</strong>，第一次实现了让垃圾收集与用户线程同时工作</p>
</li>
<li><p>目前很大一部分的Java应用集中在<strong>互联网站</strong>或者<strong>B/S系统的服务端</strong>上，这类应用<strong>尤其重视服务的响应速度</strong>，<strong>希望系统停顿时间短。</strong></p>
</li>
<li><p>CMS的垃圾收集算法采用<strong>标记-清除</strong>算法，并且也会 “Stop The World” </p>
</li>
<li><p><strong>CMS的工作原理</strong></p>
<ol>
<li><p>工作大致流程图</p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1613490686424.png" referrerpolicy="no-referrer" alt="1613490686424"></p>
</li>
<li><p>各阶段的具体工作内容</p>
<ol>
<li>初始标记阶段（Initial Mark）：在这个阶段中，所有的用户线程因为STW而停止运行，然后GC线程会<strong>仅仅标记出GC Roots能直接关联到的对象</strong>，一旦标记完成就恢复用户线程的执行，这里<strong>暂停的时间非常短</strong>。</li>
<li>并发标记阶段（Concurrent Mark）：<strong>从GC Roots的直接关联对象开始遍历整个对象图的过程</strong>，这个过程<strong>耗时较长</strong>但是<strong>不需要停止用户线程</strong>，可以一起并发运行</li>
<li>重新标记（ReMark）：由于在并发标记阶段，程序的工作线程会和垃圾收集线程并发执行，<strong>为了修正并发标记期间因用户程序运作而导致标记变动的那一部分对象标记记录</strong>，这个阶段的停顿比初始标记稍长，但远比并发标记时间短</li>
<li>并发清除（Concurrent-Sweep）阶段：此阶段<strong>清理删除标记阶段判断的已死亡的对象</strong>，释放内存空间，不需要移动存活对象。</li>

</ol>
</li>
<li><p>CMS的特点</p>
<ol>
<li>由于最耗时间的并发标记和并发清理阶段都是并发的，无需停止用户线程，因此<strong>整体的回收是低延迟的。</strong></li>
<li>由于在垃圾收集阶段用户线程没有中断，所以<strong>在CMS回收过程中，还应该确保用户线程有足够的内存可用</strong>，因此CMS不能像其他收集器那样等老年代几乎完全填满了再收集，而是<strong>当堆空间使用率达到某一阈值时便开始进行回收</strong>，以确保应用程序在CMS工作过程中依然有足够的空间支持应用程序运行。<strong>如果CMS收集过程中预留的内存无法满足程序的需要</strong>，就会出现一次“Concurrent Mode Failure”失败，这时就会<strong>启动Serial Old 收集器来重新进行老年代的垃圾收集</strong>。</li>
<li>CMS使用的是标记-清除算法，则不可避免的会<strong>产生一些内存碎片</strong>，分配内存时无法使用指针碰撞技术，而只能选择<strong>空闲链表</strong>执行内存分配。</li>

</ol>
</li>
<li><p>弊端：</p>
<ol>
<li>产生内存碎片，可能导致在分配大对象时触发Full GC</li>
<li>对CPU资源非常敏感，总吞吐量会变低</li>
<li><strong>无法处理浮动垃圾</strong>，如果在<strong>并发标记阶段产生新的垃圾</strong>，CMS无法对这些垃圾进行标记，最终可能导致这些新产生的垃圾对象没有被回收，只能等下次GC</li>

</ol>
</li>

</ol>
</li>

</ol>
<h3>八、G1收集器</h3>
<ol>
<li><p>官方给G1设定的目标是<strong>在延迟可控的情况下获得尽可能高的吞吐量</strong>。</p>
</li>
<li><p>G1（Garbage-First）是一款面向服务端应用的垃圾收集器，<strong>主要针对配置多核CPU及大容量内存的机器</strong>，以极高概率满足GC停顿时间的同时，还兼顾高吞吐量的性能特征。</p>
</li>
<li><p>JDK9及以后版本的默认垃圾收集器</p>
</li>
<li><p>G1的优势</p>
<ol>
<li><p>并行与并发</p>
<ul>
<li>并行：多个GC线程同时工作，有效利用多核计算能力，此时用户线程STW</li>
<li>并发：G1的部分工作可以与应用程序同时执行</li>

</ul>
</li>
<li><p><strong>分代收集</strong></p>
<ul>
<li>从分代上看，G1依然属于分代型垃圾回收器，它会区分年轻代和老年代，但从堆的结构来讲，它不要求整个年轻代和老年代是连续的，也不再固定大小和固定数量</li>
<li><strong>将堆空间分成若干个区域（Region）</strong>，这些区域中包含了逻辑上的年轻代和老年代。</li>
<li>和之前的各类回收器不同，它<strong>同时兼顾年轻代和老年代</strong>。其他回收器一般只处理年轻代或老年代。</li>

</ul>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1613629056501.png" referrerpolicy="no-referrer" alt="1613629056501"></p>
</li>
<li><p>空间整合</p>
<ul>
<li>G1将内存划分为一个个的Region。<strong>内存的回收是以region为基本单位的</strong>。Region之间是复制算法，但整体可看作标记-压缩算法，两种方法都可以避免内存碎片。当Java堆非常大的时候，G1优势特别明显。</li>

</ul>
</li>
<li><p>可预测的停顿模型</p>
<ol>
<li>G1除了追求低停顿之外，还能建立可预测的停顿时间模型，能够让使用者明确指定一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间最多不能超过N毫秒（<strong>大概率情况下满足</strong>）</li>
<li>由于分区的原因，G1可以只选取部分区域进行垃圾回收，这样缩小了回收的范围，因此对全局停顿情况的发生也能得到较好的控制</li>
<li>G1跟踪各个Region里面的垃圾堆积的价值大小，即回收所获得的空间大小以及回收所需时间的经验值，<strong>在后台维护一个优先列表，每次根据允许收集时间，优先回收价值最大的Region</strong>。</li>

</ol>
</li>

</ol>
</li>
<li><p>G1回收器的细节与收集过程</p>
<ol>
<li><p>化整为零</p>
<ul>
<li>G1收集器将堆分成大约2048个大小相同的独立Region块，每个Region块大小根据堆空间的实际大小而定，整体被控制在1MB到32MB之间，且为2的N次幂，即1MB,2MB,4MB,8MB... 可以通过-XX:G1HeapRegionSize设定。<strong>所有的Region大小相同，在JVM生命周期内不会改变</strong>。</li>
<li>G1收集器增加了一种内存区域，叫做Humongous内存区域，主要用来存放大对象，如果超过1.5个Region大小，就放到H。</li>

</ul>
<blockquote><p>设置H是为了那些短期存在的大对象，如果直接放到Old区会影响GC，如果一个H区装不下对象，那么G1会寻找连续的H区来存储。</p>
</blockquote>
</li>
<li><p>指针碰撞与TLAB</p>
<ul>
<li>G1使用指针碰撞来分配内存</li>
<li>支持TLAB</li>

</ul>
</li>
<li><p>回收过程</p>
<p><img src="file://D:/StudyDocument/MarkDown%E5%9B%BE%E7%89%87/1613653687670.png" referrerpolicy="no-referrer" alt="1613653687670"></p>
<ol>
<li>当年轻代的Eden区用尽时开始年轻代回收过程：<strong>G1年轻代收集阶段是一个并行的独占式收集器</strong>。在年轻代回收期，G1暂停所有应用程序线程，启动多线程执行年轻代回收。然后从年轻代移动存活对象到Survivor区或者Old区，可能是两个区间都会涉及。</li>
<li><strong>当堆内存使用到一定值（默认45%），开始老年代并发标记过程</strong>。标记完成马上开始混合回收过程。对于一个混合回收期，G1从老年代区间移动存活对象到空闲区间。G1的老年代与新生代不同，不需要回收整个老年代，一次只需扫描/回收一部分的Region，且此时老年代是与新生代一起回收的</li>

</ol>
</li>
<li><p>Remember Set——记忆集</p>
<ul>
<li>背景：由于在进行Young GC时，得判断Region中的对象是否被Old区或其他区的对象的属性所引用，如果要遍历所有的Old区，那将是无法想象的。因此每个Region区需要记录哪些对象引用了该Region的对象。</li>

</ul>
<p><img src="file://D:/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99/MarkDown%E5%9B%BE%E7%89%87/1613656420353.png" referrerpolicy="no-referrer" alt="1613656420353"></p>
<ul>
<li><strong>每个Region都有一个对应的Remember Set</strong></li>
<li>每次Reference类型数据写操作时，都会产生一个Write Barrier暂时中断操作</li>
<li>然后检查将要写入的引用指向是否和该Reference类型数据在不同的Region</li>
<li>如果不同，就通过CardTable把相关引用信息记录到引用指向对象的所在Region对应的Remember Set中</li>
<li>当垃圾收集时，在GC Roots中的枚举范围内加入Remember Set，避免全局扫描。</li>

</ul>
</li>

</ol>
<h3>九、垃圾收集器总结</h3>
<figure><table>
<thead>
<tr><th style='text-align:center;' >垃圾收集器</th><th style='text-align:center;' >分类</th><th style='text-align:center;' >作用位置</th><th style='text-align:center;' >使用算法</th><th style='text-align:center;' >特点</th><th style='text-align:center;' >使用场景</th></tr></thead>
<tbody><tr><td style='text-align:center;' >Serial</td><td style='text-align:center;' >串行运行</td><td style='text-align:center;' >新生代</td><td style='text-align:center;' >复制算法</td><td style='text-align:center;' >响应速度优先</td><td style='text-align:center;' >适用于单CPU环境下的Client模式</td></tr><tr><td style='text-align:center;' >ParNew</td><td style='text-align:center;' >并行运行</td><td style='text-align:center;' >新生代</td><td style='text-align:center;' >复制算法</td><td style='text-align:center;' >响应速度优先</td><td style='text-align:center;' >多CPU环境Server模式下与CMS配合使用</td></tr><tr><td style='text-align:center;' >Parallel</td><td style='text-align:center;' >并行运行</td><td style='text-align:center;' >新生代</td><td style='text-align:center;' >复制算法</td><td style='text-align:center;' >吞吐量优先</td><td style='text-align:center;' >适用于后台运算而不需要太多交互的场景</td></tr><tr><td style='text-align:center;' >Serial Old</td><td style='text-align:center;' >串行运行</td><td style='text-align:center;' >老年代</td><td style='text-align:center;' >标记压缩</td><td style='text-align:center;' >响应速度优先</td><td style='text-align:center;' >适用于单CPU环境下的Client模式</td></tr><tr><td style='text-align:center;' >Parallel Old</td><td style='text-align:center;' >并行运行</td><td style='text-align:center;' >老年代</td><td style='text-align:center;' >标记压缩</td><td style='text-align:center;' >吞吐量优先</td><td style='text-align:center;' >适用于后台运算而不需要太多交互的场景</td></tr><tr><td style='text-align:center;' >CMS</td><td style='text-align:center;' >并发运行</td><td style='text-align:center;' >老年代</td><td style='text-align:center;' >标记清除</td><td style='text-align:center;' >响应速度优先</td><td style='text-align:center;' >适用于互联网或B/S业务</td></tr><tr><td style='text-align:center;' >G1</td><td style='text-align:center;' >并发、并行运行</td><td style='text-align:center;' >新生代与老年代</td><td style='text-align:center;' >标记压缩、复制算法</td><td style='text-align:center;' >响应速度优先</td><td style='text-align:center;' >面向服务端应用</td></tr></tbody>
</table></figure>
<h3>十、GC日志分析</h3>
<ol>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:PrintGC</code>：在控制台输出GC日志</p>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>XX:PrintGCDetails</code>：输出GC的详情日志</p>
</li>
<li><p><code><span style='font-family:"Open Sans", "Clear Sans", "Helvetica Neue", Helvetica, Arial, sans-serif'>-</span>Xloggc:../logs/gc.log</code>：输出日志文件到指定路径</p>
</li>
<li><p>GC日志详解</p>
<ol>
<li>YoungGC的日志分析</li>

</ol>
<p><img style="zoom:150%;" alt="1613802973051" src="D:\StudyDocument\MarkDown图片\1613802973051.png" data-src="D:\StudyDocument\MarkDown图片\1613802973051.png" onerror="this.style.display = 'none';"></p>
<ol start='2' >
<li>Full GC的日志分析</li>

</ol>
<p><img style="zoom:150%;" alt="1613803228801" src="D:\StudyDocument\MarkDown图片\1613803228801.png" data-src="D:\StudyDocument\MarkDown图片\1613803228801.png" onerror="this.style.display = 'none';"></p>
</li>

</ol>
<p>&nbsp;</p>
</li>

</ol>
